> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/v123411739/article/details/79671697)

**概述**
======

现在面试 Java 开发时，基本都会问到 Java 虚拟机的知识，根据职位不同问的内容深浅又有所区别。本文整理了 10 道面试中常问的 Java 虚拟机面试题，希望对正在面试的同学有所帮助。

1. 介绍下 Java 内存区域（运行时数据区）。
=========================

Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为以下 6 个运行时数据区域。

程序计数器（Program Counter Register）

一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空。

Java 虚拟机栈（Java Virtual Machine Stacks）
--------------------------------------

与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

本地方法栈（Native Method Stack）
--------------------------

本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。

Java 堆（Java Heap）
-----------------

对大多数应用来说，Java 堆是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

方法区（Method Area）
----------------

与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区是 JVM 规范中定义的一个概念，具体放在哪里，不同的实现可以放在不同的地方。

运行时常量池（Runtime Constant Pool）
-----------------------------

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

2. 怎么判定对象已经 “死去”？
=================

常见的判定方法有两种：引用计数法和可达性分析算法，HotSpot 中采用的是可达性分析算法。

引用计数法
-----

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。

客观地说，引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，但是主流的 Java 虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。

可达性分析算法
-------

这个算法的基本思路就是通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。如下图所示，对象 object 5、object 6、object 7 虽然互相有关联，但是它们到 GC Roots 是不可达的，所以它们将会被判定为是可回收的对象。

![](https://img-blog.csdn.net/20180323192824454)  

3. 介绍下四种引用（强引用、软引用、弱引用、虚引用）？
============================

**强引用：**在程序代码之中普遍存在的，类似 “Object obj=new Object()” 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

**软引用：**用来描述一些还有用但并非必需的对象，使用 SoftReference 类来实现软引用，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。

**弱引用：**用来描述非必需对象的，使用 WeakReference 类来实现弱引用，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。

**虚引用**：是最弱的一种引用关系，使用 PhantomReference 类来实现虚引用，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

4. 垃圾收集有哪些算法，各自的特点？
===================

标记 - 清除算法
---------

首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

复制算法
----

为了解决效率问题，一种称为 “复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。

标记 - 整理算法
---------

复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。

根据老年代的特点，有人提出了另外一种 “标记 - 整理”（Mark-Compact）算法，标记过程仍然与 “标记 - 清除” 算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

5.HotSpot 为什么要分为新生代和老年代？
========================

HotSpot 根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 “标记—清理” 或者 “标记—整理” 算法来进行回收。

其中新生代又分为 1 个 Eden 区和 2 个 Survivor 区，通常称为 From Survivor 和 To Survivor 区。

![](https://img-blog.csdn.net/20180323192921352)

6. 新生代中 Eden 区和 Survivor 区的默认比例？
================================

在 HotSpot 虚拟机中，Eden 区和 Survivor 区的默认比例为 8:1:1，即 - XX:SurvivorRatio=8，其中 Survivor 分为 From Survivor 和 ToSurvivor，因此 Eden 此时占新生代空间的 80%。

7.HotSpot GC 的分类？
=================

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

1.  Partial GC：并不收集整个 GC 堆的模式，具体如下：
    
    1.  Young GC/Minor GC：只收集新生代的 GC。
        
    2.  Old GC：只收集老年代的 GC。只有 CMS 的 concurrent collection 是这个模式。
        
    3.  Mixed GC：收集整个新生代以及部分老年代的 GC，只有 G1 有这个模式。
        
2.  Full GC/Major GC：收集整个 GC 堆的模式，包括新生代、老年代、永久代（如果存在的话）等所有部分的模式。
    

8.HotSpot GC 的触发条件？
===================

这里只说常见的 Young GC 和 Full GC。

Young GC：当新生代中的 Eden 区没有足够空间进行分配时会触发 Young GC。

Full GC：

1.  当准备要触发一次 Young GC 时，如果发现统计数据说之前 Young GC 的平均晋升大小比目前老年代剩余的空间大，则不会触发 Young GC 而是转为触发 Full GC。（通常情况）
    
2.  如果有永久代的话，在永久代需要分配空间但已经没有足够空间时，也要触发一次 Full GC。
    
3.  System.gc() 默认也是触发 Full GC。
    
4.  heap dump 带 GC 默认也是触发 Full GC。
    
5.  CMS GC 时出现 Concurrent Mode Failure 会导致一次 Full GC 的产生。
    

9.Full GC 后老年代的空间反而变小？
======================

HotSpot 的 Full GC 实现中，默认新生代里所有活的对象都要晋升到老年代，实在晋升不了才会留在新生代。假如做 Full GC 的时候，老年代里的对象几乎没有死掉的，而新生代又要晋升活对象上来，那么 Full GC 结束后老年代的使用量自然就上升了。

10. 什么情况下新生代对象会晋升到老年代？
======================

1.  如果新生代的垃圾收集器为 Serial 和 ParNew，并且设置了 - XX:PretenureSizeThreshold 参数，当对象大于这个参数值时，会被认为是大对象，直接进入老年代。
2.  Young GC 后，如果对象太大无法进入 Survivor 区，则会通过分配担保机制进入老年代。
3.  对象每在 Survivor 区中 “熬过” 一次 Young GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁，可以通过 - XX:MaxTenuringThreshold 设置），就将会被晋升到老年代中。
4.  如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。

—————END—————

![](https://img-blog.csdn.net/2018040715201596)