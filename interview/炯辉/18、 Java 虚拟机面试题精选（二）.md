> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/v123411739/article/details/79692477)

概述

现在面试 Java 开发时，基本都会问到 Java 虚拟机的知识，根据职位不同问的内容深浅又有所区别。本文整理了 10 道面试中常问的 Java 虚拟机面试题，希望对正在面试的同学有所帮助。

11. 介绍下垃圾收集机制（在什么时候，对什么，做了什么）？
==============================

在什么时候？
------

在触发 GC 的时候，具体如下，这里只说常见的 Young GC 和 Full GC。

触发 Young GC：当新生代中的 Eden 区没有足够空间进行分配时会触发 Young GC。

触发 Full GC：

1.  当准备要触发一次 Young GC 时，如果发现统计数据说之前 Young GC 的平均晋升大小比目前老年代剩余的空间大，则不会触发 Young GC 而是转为触发 Full GC。（通常情况）
2.  如果有永久代的话，在永久代需要分配空间但已经没有足够空间时，也要触发一次 Full GC。
3.  System.gc() 默认也是触发 Full GC。
4.  heap dump 带 GC 默认也是触发 Full GC。
5.  CMS GC 时出现 Concurrent Mode Failure 会导致一次 Full GC 的产生。

对什么？
----

对那些 JVM 认为已经 “死掉” 的对象。即从 GC Root 开始搜索，搜索不到的，并且经过一次筛选标记没有复活的对象。

做了什么？
-----

对这些 JVM 认为已经 “死掉” 的对象进行垃圾收集，新生代使用复制算法，老年代使用标记 - 清除和标记 - 整理算法。

12.GC Root 有哪些?
===============

在 Java 语言中，可作为 GC Roots 的对象包括下面几种：

*   虚拟机栈（栈帧中的本地变量表）中引用的对象。
*   方法区中类静态属性引用的对象。
*   方法区中常量引用的对象。
*   本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。

13. 发生 Young GC 的时候需要扫描老年代的对象吗？
===============================

在分代收集中，新生代的规模一般都比老年代要小许多，新生代的收集也比老年代要频繁许多，如果回收新生代时也不得不同时扫描老年代的话，那么 Young GC 的效率可能下降不少。显然是不可能区扫描老年代的，那么是通过什么办法来解决这个问题了？

在大多垃圾收集器中（G1 有不同的地方），通过 CardTable 来维护老年代对年轻代的引用，CardTable 可以说是 Remembered Set（RS）的一种特殊实现，是 Card 的集合。Card 是一块 2 的幂字节大小的内存区域，例如 HotSpot 用 512 字节，里面可能包含多个对象。CardTable 要记录的是从它覆盖的范围出发指向别的范围的指针。以分代式 GC 的 CardTable 为例，要记录老年代指向年轻代的跨代指针，被标记的 Card 是老年代范围内的。当进行年轻代的垃圾收集时，只需要扫描年轻代和老年代的 CardTable 即可保证不对全堆扫描也不会有遗漏。CardTable 通常为字节数组，由 Card 的索引（即数组下标）来标识每个分区的空间地址。

14. 垃圾收集器有哪些？
=============

目前 HotSpot 中有 7 种作用于不同分代的收集器，如下图所示，如果两个收集器之间存在连线，就说明它们可以搭配使用。

![](https://img-blog.csdn.net/20180325234405371)  

15. 介绍 CMS 垃圾收集器的特点？
====================

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。

从名字 (包含 “Mark Sweep”) 上就可以看出，CMS 收集器是基于 “标记—清除” 算法实现的，它的运作过程可以分为 6 个步骤，包括：初始标记、并发标记、预处理、重新标记、并发清除、重置。

CMS 是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，但是 CMS 还远达不到完美的程度，它有以下 3 个明显的缺点：

1.  CMS 收集器对 CPU 资源非常敏感。
2.  CMS 收集器无法处理浮动垃圾 (Floating Garbage)，可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。
3.  CMS 是一款基于 “标记—清除” 算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。

了解 CMS 更多内容，查看我的另一篇文章：[Java 虚拟机：垃圾收集原理和垃圾收集器](https://blog.csdn.net/v123411739/article/details/78938441)

16. 介绍下 G1 垃圾收集器的特点？（较复杂，可以考虑跳过）
================================

G1(Garbage-First) 收集器是当今收集器技术发展的最前沿成果之一。G1 是一款面向服务端应用的垃圾收集器。与其他 GC 收集器相比，G1 具备如下特点：并行与并发、分代收集、空间整合、可预测的停顿。

在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。

G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。

Mixed GC 是 G1 垃圾收集器特有的收集方式，Mixed GC 大致可划分为全局并发标记（global concurrent marking）和拷贝存活对象（evacuation）两个大部分：

global concurrent marking 是基于 SATB 形式的并发标记，包括以下 4 个阶段：初始标记（Initial Marking）、并发标记（Concurrent Marking）、最终标记（Final Marking）、清理（Clean Up）。Evacuation 阶段是全暂停的。它负责把一部分 region 里的活对象拷贝到空 region 里去，然后回收原本的 region 的空间。

了解 G1 更多内容，查看我的另一篇文章：[Java 虚拟机：垃圾收集原理和垃圾收集器](https://blog.csdn.net/v123411739/article/details/78938441)

17. 类加载的过程。
===========

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 7 个阶段。其中验证、准备、解析 3 个部分统称为连接。

加载：
---

“类加载” 过程的一个阶段，在加载阶段，虚拟机需要完成以下 3 件事情：

1.  通过一个类的全限定名来获取定义此类的二进制字节流。
2.  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3.  在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

验证：
---

连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体上看，验证阶段大致上会完成下面 4 个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

准备：
---

该阶段是正式为类变量（static 修饰的变量）分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这里所说的初始值 “通常情况” 下是数据类型的零值，下表列出了 Java 中所有基本数据类型的零值。

![](https://img-blog.csdn.net/2018032523454331)  

解析：
---

该阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

初始化：
----

初始化阶段是执行类构造器 <clinit>() 方法的过程。<clinit>() 方法是由编译器自动收集类中的所有类变量（static 修饰的变量）的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。如果该类存在父类，则虚拟机会保证在执行子类的 < clinit>() 方法前，父类的 < clinit>() 方法已经执行完毕。因此在虚拟机中第一个被执行 < clinit>() 方法的类肯定是 java.lang.Object。

18.Java 虚拟机中有哪些类加载器？
====================

从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。

从 Java 开发人员的角度来看，绝大部分 Java 程序都会使用到以下 3 种系统提供的类加载器。

启动类加载器（Bootstrap ClassLoader）：
------------------------------

这个类加载器负责将存放在 <JAVA_HOME>\lib 目录中的，或者被 - Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。

扩展类加载器（Extension ClassLoader）：
------------------------------

这个加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 <JAVA_HOME>\lib\ext 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。

应用程序类加载器（Application ClassLoader）：
----------------------------------

这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

我们的应用程序都是由这 3 种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如图所示。

![](https://img-blog.csdn.net/2018032523461252)  

19. 什么是双亲委派模型？
==============

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

20. 使用双亲委派模型的好处？
================

使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。

—————END—————

![](https://img-blog.csdn.net/20180407151320546)